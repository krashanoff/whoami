
<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>krashanoff | An SSH Tarpit in 24 Lines</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="The website of Leo Krashanoff">
    <link
      rel="icon"
      href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAACXBIWXMAAC4jAAAuIwF4pT92AAAADElEQVQImWOoX/UGAAPBAhajZVPkAAAAAElFTkSuQmCC"
      type="image/png"
    />
    <link rel="stylesheet" type="text/css" href="/index.css" />
  </head>
  <body>
    
<a href="/">krashanoff</a>
<article>
  <h1>An SSH Tarpit in 24 Lines</h1>
  <small><date>Sep 27, 2021</date></small>
  <p>I found Chris Wellons' <a href="https://nullprogram.com/blog/2019/03/22/">endlessh</a>
to be very neat, so I wrote a short one in Rust. This compiles down to about
337kB after stripping metadata on the <code>current-thread</code> flavor of <a href="https://tokio.rs/"><code>tokio</code></a>.</p>
<p>If you want to try it yourself, you can run it with <code>./binname [PORT NUMBER]</code>.</p>
<pre><code class="language-rs">use std::{env, time::Duration};
use tokio::{self, io::AsyncWriteExt, net::TcpListener, time::interval};

#[tokio::main]
async fn main() {
    let port: String = env::args().skip(1).collect();
    let listener = TcpListener::bind(format!(&quot;0.0.0.0:{}&quot;, port))
        .await
        .expect(&quot;failed to bind to port&quot;);

    loop {
        if let Ok((mut stream, _)) = listener.accept().await {
            tokio::spawn(async move {
                let mut interval = interval(Duration::from_secs(5));
                loop {
                    if let Err(e) = stream.write(b&quot;\n&quot;).await {
                        eprintln!(&quot;{}&quot;, e);
                    }
                    interval.tick().await;
                }
            });
        }
    }
}
</code></pre>

</article>


    <footer>
      Copyright &copy; 2022 Leonid Krashanoff
    </footer>
  </body>
</html>
