<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Leonid Krashanoff" />
  <meta name="dcterms.date" content="2023-03-14" />
  <title>Keyword generics seem intimidating</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: blue;
    }
    a:visited {
      color: blue;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

    body {
      font-family: Georgia, 'Times New Roman', Times, serif;
    }

    figure {
      padding: 1rem;
      border: 1px solid #0b0b0b;
      display: flex;
      flex-flow: column nowrap;
      align-items: center;
    }

    figcaption {
      margin-top: 1rem;
    }

    footer {
      font-size: 0.75rem;
    }

    .codeblock {
      overflow: auto;
      overflow-wrap: normal;
      border: 1px solid black;
      padding: 1rem;
    }

    .codeblock > code {
      overflow-wrap: unset !important;
      white-space: unset;
    }

    @media print {
      .print-display-none {
        display: none;
      }
    }
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->

  <link
    rel="icon"
    href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAACXBIWXMAAC4jAAAuIwF4pT92AAAADElEQVQImWOoX/UGAAPBAhajZVPkAAAAAElFTkSuQmCC"
    type="image/png"
  />
</head>
<body>

<a class="print-display-none" href="/">Back to home</a>

<header id="title-block-header">
<h1 class="title">Keyword generics seem intimidating</h1>
<p class="author">Leonid Krashanoff</p>
<p class="date">
    <date>14 March 2023</date>
</p>



</header>
<p>You ever read <a
href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/"
rel="noopener noreferrer" referrerpolicy="no-referrer">&#x201C;What Color is Your
Function&#x201D;</a>? A pretty good lot of people have.</p>
<p>If you&#x2019;ve worked with <code>async</code>, you know how infectious function
coloring can be. If you want to write some code that can be called
asynchronously, then it definitely can&#x2019;t be called synchronously. Or, if it
can be called synchronously, it has to be done using something that feels kind
of jank. Like Python:</p>
<div class="sourceCode" id="cb1" class="codeblock"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> asyncio</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="cf">async</span> <span class="kw">def</span> thing():</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="cf">await</span> some_other_thing()</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&#39;__main__&#39;</span>:</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  result <span class="op">=</span> asyncio.run(thing)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(result)</span></code></pre></div>
<p>But most of the time, the async behavior propagates up the call stack,
until you have an <code>async</code> main. Or in Rust, where you have to stand
up a whole runtime for it:</p>
<div class="sourceCode" id="cb2" class="codeblock"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="pp">Runtime::</span>new()</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>unwrap()</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>spawn(<span class="kw">async</span> <span class="op">{</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>      <span class="pp">println!</span>(<span class="st">&quot;hi&quot;</span>)<span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Where function coloring is less of a problem is in langauges like Go, or
languages where <code>suspend/resume</code> is the way of doing async. In
those languages, functions don&#x2019;t have special keywords to be considered
asynchronous, which means that any function could be instantiated like it were
async.</p>
<div class="sourceCode" id="cb3" class="codeblock"><pre
class="sourceCode go"><code class="sourceCode go"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> longComputation<span class="op">(</span>resultChan <span class="kw">chan</span><span class="op">&lt;-</span><span class="dt">int</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  resultChan <span class="op">&lt;-</span> <span class="dv">2</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  resultChan <span class="op">:=</span> <span class="bu">make</span><span class="op">(</span><span class="kw">chan</span> <span class="dt">int</span><span class="op">)</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">go</span> longComputation<span class="op">(</span>resultChan<span class="op">)</span> <span class="co">// runs asynchronously</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// we can do stuff then block on the result later</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>  fmt<span class="op">.</span>Println<span class="op">(</span><span class="st">&quot;thing&quot;</span><span class="op">)</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>  output <span class="op">:=</span> <span class="op">&lt;-</span>resultChan</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Rust is a modern language with a huge groundswell of support. The steering
committee wants what&#x2019;s best for its users, so it makes sense that they would
benefit from solving this problem sooner than later. The Rust project recently
announced that they were planning to tackle this problem through the Keyword
Generics Initiative, whose announcement you should read <a
href="https://blog.rust-lang.org/inside-rust/2022/07/27/keyword-generics.html"
rel="noopener noreferrer" referrerpolicy="no-referrer">here</a>. Their plan
was:</p>
<blockquote>
<p>Rust allows you to be generic over types - it does not allow you to be
generic over other things that are usually specified by keywords. For example,
whether a function is async, whether a function can fail or not, whether a
function is const or not, etc.</p>
<p>The post &#x201C;What color is your function&#x201D; describes what happens when a
language introduces async functions, but with no way to be generic over
them&#x2026;</p>
<p>This isn&#x2019;t just limited to async though, it applies to all modifier
keywords - including ones we may define in the future. So we&#x2019;re looking to
fill that gap by exploring something we call &#x201C;keyword generics&#x201D;: the ability
to be generic over keywords such as const and async.</p>
<p><em>&#x2013; &#x201C;Announcing the Keyword Generics Initiative&#x201D;</em></p>
</blockquote>
<p>The tentatively proposed syntax was:</p>
<div class="sourceCode" id="cb4" class="codeblock"><pre
class="sourceCode rs"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span><span class="op">&lt;</span>A<span class="op">&gt;</span> <span class="kw">trait</span> <span class="bu">Read</span> <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">async</span><span class="op">&lt;</span>A<span class="op">&gt;</span> <span class="kw">fn</span> read(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span> buf<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> [<span class="dt">u8</span>]) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">usize</span><span class="op">&gt;;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">async</span><span class="op">&lt;</span>A<span class="op">&gt;</span> <span class="kw">fn</span> read_to_string(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span> buf<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> <span class="dt">String</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">usize</span><span class="op">&gt;</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co">/// Read from a reader into a string.</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span><span class="op">&lt;</span>A<span class="op">&gt;</span> <span class="kw">fn</span> read_to_string(reader<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">impl</span> <span class="bu">Read</span> <span class="op">*</span> A) <span class="op">-&gt;</span> <span class="pp">std::io::</span><span class="dt">Result</span><span class="op">&lt;</span><span class="dt">String</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> string <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    reader<span class="op">.</span>read_to_string(<span class="op">&amp;</span><span class="kw">mut</span> string)<span class="op">.</span><span class="kw">await</span><span class="op">?;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    string</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>To me, this seems unwieldy, but at least comprehensible: we&#x2019;re generalizing
the function over the <code>async</code> keyword itself, and introducing some
strange syntax in order to specify whether a type fulfills that optional
<code>async/await</code>-ness. Just another little nugget of Rust syntax to
notch onto the belt.</p>
<p>But, the working group recently released <a
href="https://blog.rust-lang.org/inside-rust/2023/02/23/keyword-generics-progress-report-feb-2023.html"
rel="noopener noreferrer" referrerpolicy="no-referrer">a new update on the
project</a>. After nine months, the proposed syntax is a <em>little</em>
different.</p>
<div class="sourceCode" id="cb5" class="codeblock"><pre
class="sourceCode rs"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">trait</span> <span class="op">?</span><span class="kw">async</span> <span class="bu">Read</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">?</span><span class="kw">async</span> <span class="kw">fn</span> read(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span> buf<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> [<span class="dt">u8</span>]) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">usize</span><span class="op">&gt;;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">?</span><span class="kw">async</span> <span class="kw">fn</span> read_to_string(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span> buf<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> <span class="dt">String</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">usize</span><span class="op">&gt;</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co">/// Read from a reader into a string.</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="op">?</span><span class="kw">async</span> <span class="kw">fn</span> read_to_string(reader<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">impl</span> <span class="op">?</span><span class="kw">async</span> <span class="bu">Read</span>) <span class="op">-&gt;</span> <span class="pp">std::io::</span><span class="dt">Result</span><span class="op">&lt;</span><span class="dt">String</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> string <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    reader<span class="op">.</span>read_to_string(<span class="op">&amp;</span><span class="kw">mut</span> string)<span class="op">.</span><span class="kw">await</span><span class="op">?;</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Ok</span>(string)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>I know this is still relatively early in the lifetime of the project, but I
can&#x2019;t say I&#x2019;m enthused with this. In fact, this syntax kind of makes me
anxious.</p>
<p>At least in the case of <code>async&lt;A&gt;</code>, it is pretty apparent
that it&#x2019;s an extension of the generics system in Rust, which is what they were
going for in the first place. With this new <code>?async</code>, though, the
feature presents itself syntactically as an extension of the error
propoagation system (e.g., <code>result?.do_thing()</code>) or the trait bound
system (e.g., <code>fn_name&lt;T: TraitName + ?Sized&gt;()</code>). Neither of
these lend themselves to keyword <em>generics</em>. I&#x2019;d be curious about how
this approach would scale to keywords like <code>const</code>. The Rust
userbase is getting larger, too, so I&#x2019;d be curious about how this approach
would get introduced to the stable release. These problems remind me a little
bit of a certain postincremented language.</p>
<p>And the language is already <em>really</em> gnarly in its syntax. This
snippet would kill a programmer from the 80s, and it&#x2019;s not even using lifetime
bounds to their full extent:</p>
<div class="sourceCode" id="cb6" class="codeblock"><pre
class="sourceCode rs"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">/// This is a comment that has special meaning.</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="op">,</span> Deserialize<span class="at">)]</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>serde<span class="at">(</span>rename_all<span class="at">(</span>deserialize <span class="op">=</span> <span class="st">&quot;kebab-case&quot;</span><span class="at">))]</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Thing<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">,</span> T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">/// This one, too</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  on_loan<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> T<span class="op">,</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">,</span> T<span class="op">&gt;</span> Thing<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">,</span> T<span class="op">&gt;</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> T<span class="op">:</span> <span class="bu">Clone</span> <span class="op">+</span> <span class="bu">Into</span><span class="op">&lt;</span><span class="dt">String</span><span class="op">&gt;</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">pub</span> <span class="kw">async</span> <span class="kw">fn</span> use_thing(thing_one<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> Thing<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">,</span> T<span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="dt">String</span> <span class="op">{</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    thing_one<span class="op">.</span>on_loan<span class="op">.</span>clone()<span class="op">.</span>into()</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>I realize this is an unfair observation. Any language can look gnarly when
you&#x2019;re fishing for an example of how incomprehensible it can be. But, in the
case of Rust, it can be pretty easy to find said examples. In any case, I&#x2019;m
not sure where I&#x2019;m going with this one other than &#x201C;it seems like learning Rust
as a complete beginner is only going to get harder and harder going forward,&#x201D;
and, &#x201C;I hope Rust doesn&#x2019;t evolve into the very thing it sought to
destroy&#x201D;.</p>
<p>And with that, I&#x2019;ll leave the reader with some interesting reads on Rust&#x2019;s
function coloring problem that can be readily organized into the <a
href="https://www.washington.edu/counseling/2020/06/08/the-stages-of-grief-accepting-the-unacceptable/"
rel="noopener noreferrer" referrerpolicy="no-referrer">five stages of
grief</a>, ignoring their dates of publication:</p>
<ol type="1">
<li>Denial, &#x201C;Rust&#x2019;s async isn&#x2019;t colored!&#x201D;:
https://www.hobofan.com/blog/2021-03-10-rust-async-colored/</li>
<li>Anger, critique of async Rust:
https://eta.st/2017/08/04/async-rust.html</li>
<li>Bargaining, &#x201C;Colored functions are good, actually&#x201D;:
https://www.thecodedmessage.com/posts/async-colors/</li>
<li>Depression, a follow-up to said critique:
https://eta.st/2021/03/08/async-rust-2.html</li>
<li>Acceptance, &#x201C;Rust&#x2019;s async is colored, and that&#x2019;s okay&#x201D;:
https://morestina.net/blog/1686/rust-async-is-colored</li>
</ol>

<footer>
  <p>
    Copyright &copy; 2024 Leonid Krashanoff
  </p>
  <p>
    Questions? Corrections? Comments? Write me an email.
  </p>
</footer>

</body>
</html>
