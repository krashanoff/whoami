<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Leonid Krashanoff" />
  <meta name="dcterms.date" content="2023-04-29" />
  <title>Fish rocks</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: blue;
    }
    a:visited {
      color: blue;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }

    body {
      font-family: Georgia, 'Times New Roman', Times, serif;
    }

    figure {
      padding: 1rem;
      border: 1px solid #0b0b0b;
      display: flex;
      flex-flow: column nowrap;
      align-items: center;
    }

    figcaption {
      margin-top: 1rem;
    }

    footer {
      font-size: 0.75rem;
    }

    .codeblock {
      overflow: auto;
      overflow-wrap: normal;
      border: 1px solid black;
      padding: 1rem;
    }

    .codeblock > code {
      overflow-wrap: unset !important;
      white-space: unset;
    }

    @media print {
      .print-display-none {
        display: none;
      }
    }
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->

  <link
    rel="icon"
    href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAACXBIWXMAAC4jAAAuIwF4pT92AAAADElEQVQImWOoX/UGAAPBAhajZVPkAAAAAElFTkSuQmCC"
    type="image/png"
  />
</head>
<body>

<a class="print-display-none" href="/">Back to home</a>

<header id="title-block-header">
<h1 class="title">Fish rocks</h1>
<p class="author">Leonid Krashanoff</p>
<p class="date">
    <date>29 April 2023</date>
</p>



</header>
<p>&#x201C;The command line is a programmer&#x2019;s home&#x201D;, or so they say.<a href="#fn1"
class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> I find
much truth in this. In the average work day, I probably spend a solid hour or
two in the command line building stuff, troubleshooting stuff, or reorganizing
stuff. There&#x2019;s nice clients for Git, but I think that it&#x2019;s easier to work with
Git through the command line in most cases. I use my VSCode debugger usually,
but when I was a student I loved nothing more than GDB. And for a sysadmin,
you are <em>always</em> in the terminal. While I&#x2019;m not a sysadmin, lately,
I&#x2019;ve been working more and more with Kubernetes. That means I spend <em>even
more</em> time in the terminal.</p>
<p>For a long while, I used Zsh, which I didn&#x2019;t know was short for &#x201C;Z Shell&#x201D;
until a few years ago. Zsh is good because:</p>
<ol type="1">
<li>It is reverse-compatible with Bash</li>
<li>It has good scripting extensions to Bash</li>
<li>It has a huge community behind it</li>
</ol>
<p>Most of the customizations for one&#x2019;s shell come in the form of community
extensions like <code>oh-my-zsh</code>. These extensions will give you a
custom prompt, autocomplete, better history, etc. They all work beautifully,
but as you tack on more extensions, the terminal tends to get bogged down.
Some of them also require external dependencies, like <code>fzf</code>. I
remember on my old Arch system I&#x2019;d tack on tons and tons of little extensions
to make it look really pretty, but the prompt would take like 250-500ms to
draw.</p>
<p>External dependencies are taken to the extreme when you start looking at
projects like <a href="https://starship.rs/" rel="noopener noreferrer"
referrerpolicy="no-referrer">Starship</a>, which is a wonderful piece of
software, but solves the shell customization problem by introducing a full
program that&#x2019;s called every single time you want to render your prompt instead
of just a script. There is a clear advantage, though. If you operate across
different shells in your day-to-day, then having the exact same prompt in all
of them can be handy. Personally, I think Starship is the only livable way to
use stock Bash without having an anxiety attack.</p>
<p>But this is <em>my</em> laptop. I don&#x2019;t have to use Bash.</p>
<p>If you&#x2019;re okay with sacrificing POSIX-compatibility, <a
href="https://fishshell.com/" rel="noopener noreferrer"
referrerpolicy="no-referrer">Fish</a> packs more out of the box than most
shells provide through their community packages. It has autocomplete that it
parses from your manpages, nice syntax highlighting while writing scripts, and
a neat system of events and event handlers. And, since it&#x2019;s all built into the
shell itself, there&#x2019;s no scripting overhead. As cool as my 2016 Zsh was, I
think my Fish shell is 25x faster and generally more ergonomic.</p>
<p>When I was getting started, I never really used Fish functions for more
than just a few tweaks to commands that I always use, like swapping out
<code>ls</code> for <code>exa</code>, or setting persistent options in other
comamnds. I was already happy with the built-in autocomplete and prompts, and
didn&#x2019;t have want for much else. Where things really clicked, though, was when
I started using Kubernetes.</p>
<p>If you&#x2019;re unfamiliar with Kubernetes, the driving program behind it all is
<code>kubectl</code>, which is so obtuse and option-rich that there are
projects that programmatically generate hundreds of aliases just for all its
features!<a href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a> They are supremely useful.</p>
<p>While they are generated as aliases in other shells, in Fish they are
generated as <em>abbreviations</em>, which are sort of like aliases with
superpowers. When typing out the start of an abbreviation, one can
tab-complete to see all the possible paths that could be taken. For example,
if I type &#x2018;k&#x2019; and then press tab:</p>
<pre class="codeblock"><code>&#x279C; leo@mydevice:whoami git:(==main) k6 run --help
k                                                       (Abbreviation: kubectl)
k6                                                               (command link)
ka                                 (Abbreviation: kubectl apply --recursive -f)
kadmin                                                                (command)
kadmin.local                                                          (command)
kak                                            (Abbreviation: kubectl apply -k)
kbxutil                                                          (command link)
kcc                                                                   (command)
kcditto                                                               (command)
kd                                             (Abbreviation: kubectl describe)
kdall                         (Abbreviation: kubectl describe --all-namespaces)
kdcm                                 (Abbreviation: kubectl describe configmap)
kdcmall             (Abbreviation: kubectl describe configmap --all-namespaces)
kdcml                             (Abbreviation: kubectl describe configmap -l)
kdcmn                    (Abbreviation: kubectl describe configmap --namespace)
kdcsetup                                                              (command)
kddep                               (Abbreviation: kubectl describe deployment)
kddepall           (Abbreviation: kubectl describe deployment --all-namespaces)
kddepl                           (Abbreviation: kubectl describe deployment -l)
kddepn                  (Abbreviation: kubectl describe deployment --namespace)
kdestroy                                                              (command)
kdf                             (Abbreviation: kubectl describe --recursive -f)
kding                                  (Abbreviation: kubectl describe ingress)
kdingall              (Abbreviation: kubectl describe ingress --all-namespaces)
&#x2026;and 1265 more rows</code></pre>
<p>How handy! I can see all of the different possible expansions that could be
achieved from just the letter <code>k</code> without having to keep a printout
on my desk.</p>
<p>Another two concepts that pervade most of your regular use are contexts and
namespaces. You can think of contexts as a particular set of credentials
you&#x2019;re using or a role you&#x2019;re assuming, and you can think of a namespace as a
collection of objects. Often times, you&#x2019;ll need to switch between contexts and
namespaces on the fly. Say, switching between your production and staging
environments. This happens so often that there are two community-backed
commands - <code>kubectx</code> and <code>kubens</code> - that handle the
switching for you respectively.</p>
<p>Having a ton of aliases for <code>kubectl</code> is useful, sure, but what
would really save me some keystrokes is if I had my context and namespace
information available to me at all times. Enter: events and event
handlers.</p>
<p>If we know the path to <code>kubectx</code> and <code>kubens</code> on our
systems (i.e., <code>which kubectx</code>), we can wrap them with a function
that does a little something extra. For example, we can make it emit an event
that the function was run:</p>
<pre class="fish" class="codeblock"><code>function kubectx
  /path/to/kubectx $argv
  emit kube_change
end</code></pre>
<p>&#x2026;and have that event <em>handled</em> by another function to update a
file:</p>
<pre class="fish" class="codeblock"><code>function handle_kube_change --on-event kube_change
  echo (kubectx -c) &gt; $HOME/.kube_currentctx
end</code></pre>
<p>This happens asynchronously in the current terminal process, meaning that
we can put the contents of the file into our prompt without fear of a strange
halt every time after we run a command while we wait for the next prompt to
get populated:</p>
<pre class="codeblock"><code>echo -ns &quot;Current context: (cat $HOME/.kube_currentctx)&quot;
echo -ns &quot;Current namespace: (cat $HOME/.kube_currentns)&quot;</code></pre>
<p>But that lack of POSIX-compatibility is a real zinger. Most people lean on
it quite a bit. From regular use, I&#x2019;ve only really had issue with it in two
common cases:</p>
<ol type="1">
<li>Wildcard expansion</li>
<li>Version managers</li>
</ol>
<p>The rest of the cases I&#x2019;ve seen are solved by just keeping
<code>bash</code> installed on my system. Unless the script needs to export
variables, I&#x2019;m usually pretty set.</p>
<p>These two cases are pretty easy to dodge, though. For wildcard expansion,
you just have to remember that if you want to literally pass a <code>*</code>,
the argument should be quoted somehow. And for version managers, you really
don&#x2019;t need a POSIX-compliant one. <code>nvm</code> and <code>gvm</code> are
great, sure, but I have been using <a href="https://asdf-vm.com/"
rel="noopener noreferrer" referrerpolicy="no-referrer"><code>asdf</code></a>
without any issue. Environment files can be kind of annoying since the syntax
is varied, but there are some one-liners you can use to dodge problems there,
too.<a href="#fn3" class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a> Keeping things home-grown and in my pocket
has afforded me a life free of <a href="https://github.com/edc/bass"
rel="noopener noreferrer"
referrerpolicy="no-referrer"><code>bass</code></a>.</p>
<p>POSIX-irreverant shells are on the up-and-up. <a
href="https://github.com/PowerShell/PowerShell" rel="noopener noreferrer"
referrerpolicy="no-referrer">PowerShell</a> sees use in build systems and
powerful scripts, <a href="https://www.nushell.sh/" rel="noopener noreferrer"
referrerpolicy="no-referrer">Nushell</a> provides a fancy new way of working
with tabular data in the shell, and <a
href="http://www.oilshell.org/blog/2020/01/simplest-explanation.html"
rel="noopener noreferrer" referrerpolicy="no-referrer">Oil</a> seems to be
bridging the gap.</p>
<p>Anyways, Bash and Zsh will always have a special place in my heart and
their hands in a strangle hold around my neck, but Fish is pretty cool.</p>
<aside id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>No one says this.<a href="#fnref1" class="footnote-back"
role="doc-backlink">&#x21A9;&#xFE0E;</a></p></li>
<li id="fn2"><p>https://github.com/ahmetb/kubectl-aliases<a href="#fnref2"
class="footnote-back" role="doc-backlink">&#x21A9;&#xFE0E;</a></p></li>
<li id="fn3"><p>I&#x2019;ve used this function to much success with a little
tweaking:
https://gist.github.com/nikoheikkila/dd4357a178c8679411566ba2ca280fcc<a
href="#fnref3" class="footnote-back" role="doc-backlink">&#x21A9;&#xFE0E;</a></p></li>
</ol>
</aside>

<footer>
  <p>
    Copyright &copy; 2023 Leonid Krashanoff
  </p>
  <p>
    Questions? Corrections? Comments? Write me an email.
  </p>
</footer>

</body>
</html>
