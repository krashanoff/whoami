<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Leonid Krashanoff" />
  <meta name="dcterms.date" content="2022-04-08" />
  <title>Protobufs, QUIC, Rust, and Qt</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: blue;
    }
    a:visited {
      color: blue;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }

    body {
      font-family: Georgia, 'Times New Roman', Times, serif;
    }

    figure {
      padding: 1rem;
      border: 1px solid #0b0b0b;
      display: flex;
      flex-flow: column nowrap;
      align-items: center;
    }

    figcaption {
      margin-top: 1rem;
    }

    footer {
      font-size: 0.75rem;
    }

    .codeblock {
      overflow: auto;
      overflow-wrap: normal;
      border: 1px solid black;
      padding: 1rem;
    }

    .codeblock > code {
      overflow-wrap: unset !important;
      white-space: unset;
    }

    @media print {
      .print-display-none {
        display: none;
      }
    }
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->

  <link
    rel="icon"
    href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAACXBIWXMAAC4jAAAuIwF4pT92AAAADElEQVQImWOoX/UGAAPBAhajZVPkAAAAAElFTkSuQmCC"
    type="image/png"
  />
</head>
<body>

<a class="print-display-none" href="/">Back to home</a>

<header id="title-block-header">
<h1 class="title">Protobufs, QUIC, Rust, and Qt</h1>
<p class="author">Leonid Krashanoff</p>
<p class="date">
    <date>08 April 2022</date>
</p>


<div class="tags">
<p>
  Tagged:
    <a href="/tags/software">software</a>
    <a href="/tags/server">server</a>
  </p>
</div>

</header>
<nav id="TOC" role="doc-toc">
<h2 id="toc-title">Table of Contents</h2>
<ul>
<li><a href="#on-quic" id="toc-on-quic"><span
class="toc-section-number">1</span> On QUIC</a></li>
<li><a href="#on-protobufs" id="toc-on-protobufs"><span
class="toc-section-number">2</span> On Protobufs</a>
<ul>
<li><a href="#on-async-rust" id="toc-on-async-rust"><span
class="toc-section-number">2.1</span> On Async Rust</a></li>
<li><a href="#on-qt" id="toc-on-qt"><span
class="toc-section-number">2.2</span> On Qt</a></li>
</ul></li>
<li><a href="#takeaways" id="toc-takeaways"><span
class="toc-section-number">3</span> Takeaways</a></li>
</ul>
</nav>
<p>What if we wrote an open-source Discord?</p>
<p>I was trying to write a small communication client/server for my girlfriend
and I in my spare time. We would just use it for text chat or voice chat. At
the beginning, I didn&#x2019;t have much of a purpose for writing it aside from
running away from Discord after they started talking about NFTs, but I
eventually made it my goal to make it as intricate as possible - a polyglot
project. I never actually finished it, but it left me with lessons in working
with intricate software.</p>
<p>For an application that might transport things like photos, videos, or
voice communications, security is pretty paramount. One aspect of security is
<em>whose hands the data is in</em>. For my purposes of chatting with friends,
family, etc., I&#x2019;d like to keep it in my own. This meant the servers would be
self-hosted, and should be designed with this in mind. I have been writing a
lot of Rust, so I figured I would write the server in Rust. To keep the code
easy-to-maintain, I would make the server async.</p>
<p>I also wanted the client applications to be performant. There isn&#x2019;t much
wiggle room on this front. Pretty much the only good-looking, non-web-based
GUI framework these days is Qt, which only <em>really</em> works if you&#x2019;re
writing your application in C++ (although there are some high-quality bindings
to other programming languages).</p>
<p>Rust and C++ serialization formats don&#x2019;t exactly play well together,
though. This meant I needed a lingua-franca for the two to communicate with
one another on the wire. I settled on QUIC-transported protobufs for speed and
security. The rest of this entry will be some thoughts on how I built this
toolchain on Windows and Mac, and the hardships I encountered throughout.</p>
<section id="on-quic" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> On QUIC</h1>
<p>Choosing QUIC was a good call. QUIC is secure by default and designed with
speed in mind. It enforces use of TLS, and keeps things speedy by modeling
network communications between computers as multiple simultaneous,
uni-or-bidirectional streams over a UDP &#x201C;connection&#x201D;. Since packets don&#x2019;t need
to all be delivered in order, multiple streams can be processed concurrently.
This gave me a lot of freedom in how I modeled the endpoints for communication
between client and server.</p>
<p>I treated the server as though it were a single endpoint, where each stream
ID per-client dictated the type of traffic involved. This proved to be more of
a headache than I thought, as QUIC streams aren&#x2019;t exactly opened and closed
like TCP sockets, but instead treated like green threads. You won&#x2019;t get a
specific ID unless you ask explicitly for it. This is why QUIC is superior to
TCP, but also what makes it more complex.</p>
<p>The big thing I didn&#x2019;t anticipate is that <strong>QUIC has weird
libraries!</strong> QUIC is a protocol that was designed to be testable, which
means that all the libraries out there are Bring Your Own IO. The problem with
this is that libraries are pretty pigeonholed into working something like
this:</p>
<p><img src="/mediadir/06986f45a1e7dbd5f50f737415de3a1f001cfc6a.png"
loading="lazy" alt="" /></p>
<p>There were a few libraries that handle the IO for you, but there really
weren&#x2019;t enough <strong>high-level, easy to use libraries</strong> out there in
the same way that there are for protocols like RTMP. There&#x2019;s Amazon&#x2019;s
<code>s2n</code>, but the library doesn&#x2019;t allow the user a great degree of
control over the granularity of parallelism, favoring a massively-parallel
green-thread approach. The best one riding that fine line that I found was
Cloudflare&#x2019;s <code>quiche</code>, although this too had its shortcomings<a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a> in the form of C-friendly event-loop-style
packet processing.</p>
<p>Quiche aside, I played around with almost <em>every major QUIC library</em>
just to get a feel for how they worked. I tried MsQuic and Quiche on my GUI;
Quiche, Quinn, and s2n on my Rust backend; quic-go on a tiny little Go client
for testing; and aioquic on another Python client that I built for testing.
Overall, it was an insane amount of work for what felt like minimal payoff
when I just came back to using Quiche. Here are a few thoughts on each of
these, though:</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Language(s)</th>
<th style="text-align: left;">Review</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="https://github.com/cloudflare/quiche" rel="noopener noreferrer"
referrerpolicy="no-referrer">Quiche</a></td>
<td>Rust, C/C++</td>
<td style="text-align: left;">Good, but verbose</td>
</tr>
<tr class="even">
<td><a href="https://github.com/quinn-rs/quinn" rel="noopener noreferrer"
referrerpolicy="no-referrer">Quinn</a></td>
<td>Rust</td>
<td style="text-align: left;">Where&#x2019;s the <em>real</em> entry point for the
library?</td>
</tr>
<tr class="odd">
<td><a href="https://github.com/aws/s2n-quic" rel="noopener noreferrer"
referrerpolicy="no-referrer">s2n</a></td>
<td>Rust</td>
<td style="text-align: left;">Good, but maybe a little <em>too</em> abstract.
Almost every single part of the library is carried out on its own async
task.</td>
</tr>
<tr class="even">
<td><a href="https://github.com/lucas-clemente/quic-go"
rel="noopener noreferrer" referrerpolicy="no-referrer">quic-go</a></td>
<td>Go</td>
<td style="text-align: left;">Easy to use</td>
</tr>
<tr class="odd">
<td><a href="https://github.com/aiortc/aioquic" rel="noopener noreferrer"
referrerpolicy="no-referrer">aioquic</a></td>
<td>Python</td>
<td style="text-align: left;">Confusing</td>
</tr>
<tr class="even">
<td><a href="https://github.com/microsoft/msquic" rel="noopener noreferrer"
referrerpolicy="no-referrer">MsQuic</a></td>
<td>C/C++</td>
<td style="text-align: left;">OK, but the use of a function table and registry
is confusing</td>
</tr>
</tbody>
</table>
</section>
<section id="on-protobufs" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> On
Protobufs</h1>
<p>Again, the right call was protobufs. The serialization format is
well-defined and easily interoperable with other languages like Python and Go.
There are also unofficial extensions to allow protobufs to operate within
Rust.</p>
<p><em>Deploying</em> protobufs was a little more trouble than I thought it
would be, though &#x2013; especially on Windows. When I was building the library, I
had to sit there and agonize about which linker I was using. After pulling
your hair out over which linker is the same one that Qt is using, then you
have to find out whether the linker is building the library multithreaded or
not, then override flags in the Qt Makefile configuration to fix the link
issue.</p>
<p>In my case, protobufs was being built singlethreaded, but my Qt application
was not. I wanted to statically-link the library, though, so I disabled the
multithreaded linking.</p>
<section id="on-async-rust" class="level2" data-number="2.1">
<h2 data-number="2.1"><span class="header-section-number">2.1</span> On Async
Rust</h2>
<p>My initial architecture for the Rust-based server was programmatically
intuitive, at expense of design complexity. Each time the server received a
connection, it spawn off a data structure to handle future requests from the
client. The structure can send the &#x201C;conductor&#x201D; messages through its
transmitting MPSC channel, and handle incoming messages through its receiving
channel. Then when we need to talk to the individual client from the
conductor, we fetch its sender handle.</p>
<p>This established a strong separation of concerns and was motivated by the
idea of ensuring that the bottleneck for the program was in the QUIC state
manager - not the database operations or global state updates. Frogs could
handle the operation requested by the client on their own time, then send the
messages back to the <code>Bullfrog</code> to relay.</p>
<p>Something that I overlooked when building this though was the overhead from
the async runtime. All those channels moving data across thread boundaries is
<em>expensive</em>, even for something in Rust. Two great quotes came to mind
while I was building this ridiculously complicated setup.</p>
<blockquote>
<p>Think of it this way: threads are like salt, not like pasta. You like salt,
I like salt, we all like salt. But we eat more pasta.</p>
<p>&#x2014; Larry McVoy<a href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a></p>
</blockquote>
<blockquote>
<p>A computer is a state machine. Threads are for people who can&#x2019;t program
state machines.</p>
<p>&#x2014; Alan Cox<a href="#fn3" class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a></p>
</blockquote>
<p>The second one really started to stick with me when I went back to review
the architecture of the server source given in the official Quiche examples.
Their server is a simple state machine. I tried refactoring mine to reflect
this, but managing futures for database transactions proved a headache.</p>
<p>In an unexpected turn, I settled on using Amazon&#x2019;s <code>s2n-quic</code>
and its massively-parallel approach. It was just easier to use, but the
problem was that maintaining shared state became expensive for the same
reasons I encountered in my original approach.</p>
</section>
<section id="on-qt" class="level2" data-number="2.2">
<h2 data-number="2.2"><span class="header-section-number">2.2</span> On
Qt</h2>
<p>Qt is pretty much the only GUI framework that isn&#x2019;t web-based. I like the
ideas presented by projects like iced or yew, but they are still, ultimately,
web technologies. I don&#x2019;t really wanna deal with a JS interpreter or JIT
compiler - give me native widgets, please. Qt&#x2019;s new markup language, QML, is a
lot higher level than the widgets bindings, but computationally more
expensive. Under the hood, it uses OpenGL and what amounts to a stripped-down
web engine - the very thing I was trying to avoid from the get-go.</p>
<p>In keeping with my goal of making the application as lightweight as
possible, I opted to use widgets, but designing my components to be
QML-compatible as well. This is accomplished with macros in header files for
Qt types.</p>
<p>I like the ideas of Qt. It&#x2019;s a very easy-to-grasp parallel GUI framework
that lets the developer do pretty much anything they want to&#x2026;</p>
<p>&#x2026;except capture AV.</p>
<p>In Qt6, they have done no favors in making it easy to access the underlying
frames of a camera or the PCM audio. They have this brand new thing
<code>QMediaCaptureSession</code>, and they <em>really</em> want you to use
their <code>QMediaRecorder</code> class to record videos and stuff. The
problem is that there&#x2019;s almost <strong>zero</strong> extensibility in the
<code>QMediaRecorder</code> class. There&#x2019;s no way for the developer to
implement their own. I had middling success implementing a
<code>QVideoSink</code> and <code>QAudioSink</code> to catch the recording
output, but I think I&#x2019;d just use <code>ffmpeg</code> instead.</p>
</section>
</section>
<section id="takeaways" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span>
Takeaways</h1>
<p>I didn&#x2019;t really do much! I just kinda explored a bunch of different
technologies and tried - to varying levels of success - to use them all
together. GUI is hard; capturing A/V from C++ is hard; emerging protocols are
still getting their footing.</p>
<p>Writing projects that bridge languages isn&#x2019;t too hard as long as you have a
lingua franca for them to speak over the network or interprocess. There&#x2019;s a
great read about that somewhere<a href="#fn4" class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a>. In my case, I used protobufs on QUIC, and
it worked pretty well. For future projects, I would likely avoid QUIC as the
libraries aren&#x2019;t high-level enough yet that they&#x2019;re ergonomic to use.</p>
<p>There&#x2019;s also the issue of deployment. Protobufs were difficult to deploy on
machines that run Windows, as static linkage issues were pretty common. On
OSX/UNIX-like, it was a breeze.</p>
<p>I like the ideas in Qt - conceptually they are powerful - however the lack
of extensibility for the <code>QMediaRecorder</code> type made native audio
and video capture pretty difficult. It wasn&#x2019;t exactly friendly to streaming AV
capture. I would rather do the project in something like Python with Qt
bindings or maybe something that uses <a
href="https://gstreamer.freedesktop.org/" rel="noopener noreferrer"
referrerpolicy="no-referrer">GStreamer</a>, I think. With PyQt, I could do
more intricate image processing of live captures with something like pillow.
The only concern there is performance and deployment woes.</p>
<p>This project will likely be retired, but in any case, it was a good
experience being able to explore new technologies and tying heterogeneous
programs together.</p>
</section>
<aside id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>https://github.com/cloudflare/quiche/pull/1085<a
href="#fnref1" class="footnote-back" role="doc-backlink">&#x21A9;&#xFE0E;</a></p></li>
<li id="fn2"><p>Both of these quotes are from the Qt wiki, actually.
https://wiki.qt.io/Threads_Events_QObjects<a href="#fnref2"
class="footnote-back" role="doc-backlink">&#x21A9;&#xFE0E;</a></p></li>
<li id="fn3"><p>Both of these quotes are from the Qt wiki, actually.
https://wiki.qt.io/Threads_Events_QObjects<a href="#fnref3"
class="footnote-back" role="doc-backlink">&#x21A9;&#xFE0E;</a></p></li>
<li id="fn4"><p>https://gankra.github.io/blah/c-isnt-a-language/<a
href="#fnref4" class="footnote-back" role="doc-backlink">&#x21A9;&#xFE0E;</a></p></li>
</ol>
</aside>

<footer>
  <p>
    Copyright &copy; 2024 Leonid Krashanoff
  </p>
  <p>
    Questions? Corrections? Comments? Write me an email.
  </p>
</footer>

</body>
</html>
