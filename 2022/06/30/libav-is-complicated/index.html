
<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>krashanoff</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="The website of Leo Krashanoff">
    <link
      rel="icon"
      href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAACXBIWXMAAC4jAAAuIwF4pT92AAAADElEQVQImWOoX/UGAAPBAhajZVPkAAAAAElFTkSuQmCC"
      type="image/png"
    />
    <link rel="stylesheet" type="text/css" href="/index.css" />
  </head>
  <body>
    
<a href="/">krashanoff</a>
<article>
  <h1>Libav is complicated</h1>
  <small><date>Jun 30, 2022</date></small>
  <p>Libav is the crustiest library I have ever used. In a cruel paradox, it is also the state of the art in multimedia processing. Nothing comes close in performance and capability. I have been trying to write a program using it and have since gained an understanding of how to use it (kind of). With use, I feel my appreciation swelling for it, but it is still quite the complicated beast.</p>
<p>First, let's discuss the chaos that is &quot;libav&quot;. The library behind FFMPEG is called &quot;libav&quot;. Most of the library components follow the same pattern: &quot;libavdevice, libavutil&quot;, etc. Long ago, when FFMPEG was getting some traction, some folks forked the library component of it and tried to make it easier to use, or something... This mysterious spinoff was -- as in the infinite wisdom of the universe -- <em>also</em> named &quot;libav&quot;.</p>
<p>libav (the forked one) is no longer under development, as far as I can tell. The last release was in 2018. The last commit to <code>master</code> was in 2019. My brain is still stuck in the 2010s, so I have to remind myself that's <strong>three years without a commit</strong>. That seems pretty abandoned to me.</p>
<p>Normally, that a fork of a major project ceased development is no big deal, but it poses a challenge for developers; particularly when they need help. Google something about &quot;libav&quot; and look for a StackOverflow answer. It's a Russian Roulette of whether the answer you're going to get is about &quot;libav&quot; or <em>&quot;libav&quot;</em>.<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<p>Another complicated part: the eager developer might run into is that the documentation of the actual libav is terse. It is so distilled, so crystallized, that it takes a lot of careful inference and/or luck to get the hang of. There's also quite a few structure-specific quirks. For example, <code>AVChannelLayout</code> is a member of a few different data structures, and is initialized with some predefined initializers. Unlike structures in libav initialized with predefined constants, though, it must be copied with a specific function, and uninitialized with another.<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p>
<p><img src="/static/img/libav/avchannel.png" alt="documentation for avchannel"></p>
<p>There are also a few missing features from the library. For one, <a href="https://trac.ffmpeg.org/wiki/DirectShow#Howtoprogrammaticallyenumeratedevices">there is no way to programmatically enumerate devices</a>. Instead, the programmer could either shell out to <code>ffmpeg</code>, defeating the purpose of using libav in most cases, or install a log capture handler via <a href="https://ffmpeg.org/doxygen/trunk/group__lavu__log.html#ga14034761faf581a8b9ed6ef19b313708"><code>log_set_callback()</code></a>.</p>
<p>The final barrier to entry is building the library into software. Engineering complex software in C/C++ is pretty hard to get right, but baking it all together in the right ways on every platform is especially difficult. This is why almost all (if not every) modern programming language has its own toolchain that manages the compilation and linking for you. libav is designed to build on a whole lot of platforms, though, and not many programming languages short of Go can make claims to C's throne of portability.</p>
<p>Building <code>ffmpeg</code> is actually incredibly easy if you have the dependencies on your system; just <code>./configure &amp;&amp; make</code> like any other. Even if you don't have all the dependencies, you can avoid their use by just disabling them in your call to <code>configure</code>. To build it into another piece of software using something like CMake, the developer is kind of on their own with linking in all the required dependencies of the libraries. I ended up using <code>pkg-config</code>. To point <code>pkg-config</code> in the right direction in CMake, though, one has to set the <code>PKG_CONFIG_PATH</code>. My current approach is this in the root <code>CMakeLists.txt</code>:</p>
<pre><code class="language-cmake">set($ENV{PKG_CONFIG_PATH} &quot;${FFMPEG_DIR}/pkgconfig&quot;)
find_package(PkgConfig REQUIRED)
if(NOT ${PKG_CONFIG_FOUND})
  message(FATAL_ERROR &quot;Missing pkg-config!&quot;)
endif()
pkg_check_modules(CODEC REQUIRED IMPORTED_TARGET libavcodec)
pkg_check_modules(DEVICE REQUIRED IMPORTED_TARGET libavdevice)
pkg_check_modules(FILTER REQUIRED IMPORTED_TARGET libavfilter)
pkg_check_modules(FORMAT REQUIRED IMPORTED_TARGET libavformat)
pkg_check_modules(UTIL REQUIRED IMPORTED_TARGET libavutil)
pkg_check_modules(POSTPROC REQUIRED IMPORTED_TARGET libpostproc)
pkg_check_modules(SWRESAMPLE REQUIRED IMPORTED_TARGET libswresample)
pkg_check_modules(SWSCALE REQUIRED IMPORTED_TARGET libswscale)
</code></pre>
<p>Then, for the executables that need it, they can include the libraries in their subdirectories:</p>
<pre><code class="language-cmake">target_link_libraries(myExecutable PRIVATE
  PkgConfig::UTIL
  PkgConfig::SWSCALE
)
</code></pre>
<p>In the face of all this complexity, I have been able to get my software building and learn quite a bit in the process. Greatly simplifying, the basic setup of a program using libav boils down to:</p>
<ol>
<li>Provide hints about what you want to encode or decode</li>
<li>Open the input or output device in the <code>InputContext</code> or <code>OutputContext</code></li>
<li>Find the stream you want matching the format you want</li>
<li>Allocate a <code>CodecContext</code></li>
<li>Copy the codec parameters to the context (the parameters from
your discovered stream)</li>
<li>Load the decoder you want</li>
<li>Start reading/writing data</li>
</ol>
<p>If I were to write out a complete example, it would probably end up being in the ballpark of 500-1000 lines, so I'll abbreviate. A few relevant calls for this are:</p>
<ol>
<li><code>av_dict_set</code>; <code>av_find_*_format</code></li>
<li><code>avformat_open_input</code></li>
<li><code>avformat_find_stream_info</code></li>
<li><code>avcodec_alloc_context</code></li>
<li><code>avcodec_parameters_to_context</code></li>
<li><code>av_find_encoder</code>/<code>av_find_decoder</code>; <code>avcodec_open2</code></li>
<li><code>av_read_frame</code></li>
</ol>
<p>Anyways, what I'm trying to say is that using FFMPEG is a laborious process. As they say in the world of Gentoo, though, FFMPEG is a lot like configuring a kernel:</p>
<blockquote>
<p>Manually configuring a kernel is often seen as the most difficult procedure a Linux user ever has to perform. Nothing is less true -- after configuring a couple of kernels you don't even remember that it was difficult ;) <sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></p>
</blockquote>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>And what a mess it is!</p>
<ul>
<li><a href="https://video.stackexchange.com/questions/15346/libav-x264-failed-to-compile-with-hi422p-profile-and-mp4-container-support#comment20623_15346">https://video.stackexchange.com/questions/15346/libav-x264-failed-to-compile-with-hi422p-profile-and-mp4-container-support#comment20623_15346</a></li>
<li><a href="https://stackoverflow.com/questions/25716829/using-ffmpeg-and-libav">https://stackoverflow.com/questions/25716829/using-ffmpeg-and-libav</a></li>
</ul>
 <a href="#fnref1" class="footnote-backref">↩︎</a></li>
<li id="fn2" class="footnote-item"><p><a href="https://ffmpeg.org/doxygen/trunk/structAVChannelLayout.html">https://ffmpeg.org/doxygen/trunk/structAVChannelLayout.html</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p><a href="https://wiki.gentoo.org/wiki/Handbook:AMD64/Installation/Kernel">https://wiki.gentoo.org/wiki/Handbook:AMD64/Installation/Kernel</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

</article>


    <footer>
      Copyright &copy; 2022 Leonid Krashanoff
    </footer>
  </body>
</html>
